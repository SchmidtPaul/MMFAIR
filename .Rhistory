mod.wk1 <- lm(formula = y ~ variety + block,
data = dat.wk1)
mod.iid <- nlme::gls(model = y ~ factweek * (variety + block),
weights = NULL, # default, i.e. homoscedastic errors
data = dat)
mod.iid
mod.lme4.iid <- lme4::lmer(formula = y ~ factweek * (variety + block),
data    = dat)
glmmTMB(formula = y ~ factweek * (variety + block),
dispformula = ~ 1,  # = default i.e. homoscedastic error variance
REML = TRUE,        # needs to be stated since default = ML
data = dat)
mod1.glmm <- glmmTMB(formula = y ~ factweek * (variety + block),
dispformula = ~ 1,  # = default i.e. homoscedastic error variance
REML = TRUE,        # needs to be stated since default = ML
data = dat)
anova(mod1.glmm)
Anova(mod1.glmm)
car::Anova(mod1.glmm)
mod.iid.glmm <- glmmTMB(formula = y ~ factweek * (variety + block),
dispformula = ~ 1,  # = default i.e. homoscedastic error variance
REML = TRUE,        # needs to be stated since default = ML
data = dat)
mod.iid.glmm %>%
tidy(effects = "ran_pars", scales = "vcov") %>%
separate(term, sep = "__", into = c("term", "grp")) %>%
filter(group == "Residual")
mod.iid.glmm
mod.iid.glmm %>%
tidy(effects = "ran_pars", scales = "vcov")
mod.iid.glmm %>% tidy
mod.iid.glmm %>% tidy %>% print(n=Inf)
mod.iid.glmm$fit$par
mod.iid.glmm$modelInfo$terms
mod.iid.glmm$sdr$par.random
mod.iid.glmm %>% VarCorr()
mod.iid.glmm
dat <- dat %>%
mutate(unit = 1:n() %>% as.factor) # new column with running number
mod.iid.glmm <- glmmTMB(formula = y ~ factweek * (variety + block) + (1 | unit),
dispformula = ~ 0,  # = default i.e. homoscedastic error variance
REML = TRUE,        # needs to be stated since default = ML
data = dat)
mod.iid.glmm %>%
tidy(effects = "ran_pars", scales = "vcov") %>%
separate(term, sep = "__", into = c("term", "grp")) %>%
filter(group == "Residual")
mod.iid.glmm %>%
tidy(effects = "ran_pars", scales = "vcov")
mod.iid.glmm %>%
tidy(effects = "ran_pars", scales = "vcov") %>%
separate(term, sep = "__", into = c("term", "grp"))
mod.iid.glmm %>%
tidy(effects = "ran_pars", scales = "vcov")
dat <- agridat::mcconway.turnip %>%
mutate(unit = 1:n() %>% as.factor,
densf = density %>% as.factor) %>%
mutate(date_densf = interaction(date, densf))
dat <- agridat::mcconway.turnip %>%
mutate(unit = 1:n() %>% as.factor)
dat <- agridat::mcconway.turnip %>%
mutate(unit = 1:n() %>% as.factor)
# random block effect
mixed.mod <- glmmTMB::glmmTMB(formula = yield ~ gen + (1 | block),
dispformula = ~ 1, # default
REML = TRUE,
data = dat)
# fixed block effect
fixed.mod <- glmmTMB::glmmTMB(formula = yield ~ gen + block,
dispformula = ~ 1, # default
REML = TRUE,
data = dat)
# fixed block effect, but error variance forced in G-side
pseudomixed.mod <- glmmTMB::glmmTMB(formula = yield ~ gen + block + (1 | unit), # mimic error variance
dispformula =  ~ 0, # fix original error variance to 0
REML = TRUE,
data = dat)
mixed.mod %>% tidy(effects = "ran_pars", scales = "vcov")
mixed.mod       %>% tidy(effects = "ran_pars", scales = "vcov")
fixed.mod       %>% tidy(effects = "ran_pars", scales = "vcov")
pseudomixed.mod %>% tidy(effects = "ran_pars", scales = "vcov")
sessionInfo()
pseudomixed.mod %>% tidy(effects = "ran_pars", scales = "vcov") # "residual" variance
# random block effect
mixed.mod <- glmmTMB(formula = yield ~ gen + (1 | block),
dispformula = ~ 1, # default
REML = TRUE, data = dat)
dat <- agridat::mcconway.turnip %>%
mutate(unit = 1:n() %>% as.factor)
# random block effect
mixed.mod <- glmmTMB(formula = yield ~ gen + (1 | block),
dispformula = ~ 1, # default
REML = TRUE, data = dat)
# fixed block effect
fixed.mod <- glmmTMB(formula = yield ~ gen + block,
dispformula = ~ 1, # default
REML = TRUE, data = dat)
# fixed block effect, but error variance forced in G-side as random unit effect
pseudomixed.mod <- glmmTMB(formula = yield ~ gen + block + (1 | unit), # mimic error variance
dispformula =  ~ 0, # fix original error variance to 0
REML = TRUE, data = dat)
mixed.mod       %>% tidy(effects = "ran_pars", scales = "vcov") # block and residual variance
fixed.mod       %>% tidy(effects = "ran_pars", scales = "vcov") # empty tibble
pseudomixed.mod %>% tidy(effects = "ran_pars", scales = "vcov") # "residual" variance
mod.iid.glmm %>%
tidy(effects = "ran_pars", scales = "vcov") %>%
separate(term, sep = "__", into = c("term", "grp"))
mod.iid.glmm %>%
tidy(effects = "ran_pars", scales = "vcov") %>%
separate(term, sep = "__", into = c("term", "grp")) %>%
mutate(grp = "pseudoResidual")
mod.iid.glmm %>%
tidy(effects = "ran_pars", scales = "vcov") %>%
separate(term, sep = "__", into = c("term", "grp")) %>%
mutate(grp = "pseudo Residual")
mod.iid.glmm %>%
tidy(effects = "ran_pars", scales = "vcov") %>%
separate(term, sep = "__", into = c("term", "grp")) %>%
mutate(grp = "Residual")
mod.iid.glmm %>%
tidy(effects = "ran_pars", scales = "vcov") %>%
separate(term, sep = "__", into = c("term", "grp"))
# get r files from rmd files
knitr::purl("heterogeneous_error_variance.Rmd",documentation=0)
knitr::purl("autoregressive_time_series.Rmd",documentation=0)
knitr::purl("autoregressive_time_series.Rmd", documentation = 0)
params <-
list(hilang = "sas")
options(knitr.kable.NA = '')
# packages for better formatting tables for html output
library(kableExtra)
library(formattable)
library(htmltools)
# packages
pacman::p_load(dplyr, purrr, tibble, tidyr, stringr, # data handling
ggplot2, viridis,            # plot
nlme, lme4, glmmTMB, sommer, # mixed modelling
AICcmodavg, broom.mixed)     # mixed model extractions
# data
dat <- agriTutorial::sorghum %>%
rename(block = Replicate, plot = factplot) %>%
dplyr::select(y, variety, block, plot, factweek, varweek) %>%
as_tibble()
dat %>%
kable(escape = FALSE) %>%
kable_styling(bootstrap_options = c("bordered", "hover", "condensed", "responsive"),
full_width = FALSE) %>%
scroll_box(height = "200px")
ggplot(data = dat, aes(
y = y,
x = factweek,
group = variety,
color = variety
)) +
geom_point(alpha = 0.5, size = 3) +
scale_color_viridis(option = "D",
discrete = TRUE,
name = "Variety") +
scale_y_continuous(
name = "Leaf area index",
limits = c(0, 6.5),
expand = c(0, 0),
breaks = c(0:6)
) +
xlab("Week") +
theme_bw() +
theme(legend.position = "bottom")
dat.wk1 <- dat %>% filter(factweek == "1") # subset data from first week only
mod.wk1 <- lm(formula = y ~ variety + block,
data = dat.wk1)
mod.iid.nlme <- nlme::gls(model = y ~ factweek * (variety + block),
weights = NULL, # default, i.e. homoscedastic, independent errors
data = dat)
# Extract variance component estimates
mod.iid.nlme.VC <- tibble(grp = "iid", varStruct = 1) %>%
mutate(sigma         = mod.iid.nlme$sigma) %>%
mutate(StandardError = sigma*varStruct) %>%
mutate(Variance      = StandardError^2)
dat <- dat %>%
mutate(unit = 1:n() %>% as.factor) # new column with running number
mod.iid.glmm <- glmmTMB(formula = y ~ factweek * (variety + block)
+ (1 | unit),      # add random unit term to mimic error variance
dispformula = ~ 0, # fix original error variance to 0
REML = TRUE,       # needs to be stated since default = ML
data = dat)
# Extract variance component estimates
mod.iid.glmm.VC <- mod.iid.glmm %>%
tidy(effects = "ran_pars", scales = "vcov") %>%
separate(term, sep = "__", into = c("term", "grp"))
mod.iid.glmm.VC
knitr::purl("heterogeneous_error_variance.Rmd", documentation = 0)
knitr::purl("autoregressive_time_series.Rmd", documentation = 0)
params <-
list(hilang = "sas")
# packages
pacman::p_load(dplyr, purrr, tibble, tidyr, stringr, # data handling
ggplot2, viridis,            # plot
nlme, lme4, glmmTMB, sommer, # mixed modelling
AICcmodavg, broom.mixed)     # mixed model extractions
# data
dat <- agriTutorial::sorghum %>%
rename(block = Replicate, plot = factplot) %>%
dplyr::select(y, variety, block, plot, factweek, varweek) %>%
as_tibble()
dat.wk1 <- dat %>% filter(factweek == "1") # subset data from first week only
mod.wk1 <- lm(formula = y ~ variety + block,
data = dat.wk1)
mod.iid.nlme <- nlme::gls(model = y ~ factweek * (variety + block),
weights = NULL, # default, i.e. homoscedastic, independent errors
data = dat)
# Extract variance component estimates
mod.iid.nlme.VC <- tibble(grp = "iid", varStruct = 1) %>%
mutate(sigma         = mod.iid.nlme$sigma) %>%
mutate(StandardError = sigma*varStruct) %>%
mutate(Variance      = StandardError^2)
dat <- dat %>%
mutate(unit = 1:n() %>% as.factor) # new column with running number
mod.iid.glmm <- glmmTMB(formula = y ~ factweek * (variety + block)
+ (1 | unit),      # add random unit term to mimic error variance
dispformula = ~ 0, # fix original error variance to 0
REML = TRUE,       # needs to be stated since default = ML
data = dat)
# Extract variance component estimates
mod.iid.glmm.VC <- mod.iid.glmm %>%
tidy(effects = "ran_pars", scales = "vcov") %>%
separate(term, sep = "__", into = c("term", "grp"))
mod.iid.glmm.VC
mod.ar1.nlme <- nlme::gls(model = y ~ factweek * (variety + block),
corr = corExp(form =  ~ varweek | factplot), # corExp without nugget
data = dat)
dat
mod.ar1.nlme <- nlme::gls(model = y ~ factweek * (variety + block),
corr = corExp(form =  ~ varweek | plot), # corExp without nugget
data = dat)
mod.ar1.nlme <- nlme::gls(model = y ~ factweek * (variety + block),
corr = corExp(form =  ~ factweek | plot), # corExp without nugget
data = dat)
mod.ar1.nlme
as.numeric(exp(-1/coef(mod.ar1.nlme$modelStruct$corStruct, unconstrained=F)))
mod1 <- nlme::gls(model = y ~ factweek * (variety + block),
corr = corExp(form =  ~ factweek | plot),
data = dat)
mod2 <- nlme::gls(model = y ~ factweek * (variety + block),
corr = corExp(form =  ~ varweek | plot), # corExp without nugget
data = dat)
as.numeric(exp(-1/coef(mod1$modelStruct$corStruct, unconstrained=F)))
as.numeric(exp(-1/coef(mod2$modelStruct$corStruct, unconstrained=F)))
View(dat)
library(data.table)
fwrite(dat, file="autoregressive_time_series_data.txt", sep="\t")
fwrite(dat, file="autoregressive_time_series_data.txt")
fwrite(dat, file="data_autoregressive_time_series.txt", sep=" ")
as.numeric(exp(-1/coef(mod1$modelStruct$corStruct, unconstrained=F)))
as.numeric(exp(-1/coef(mod2$modelStruct$corStruct, unconstrained=F)))
mod3 <- nlme::gls(model = y ~ factweek * (variety + block),
corr = corAR1(form = ~ varweek | plot), # corExp without nugget
data = dat)
mod3
mod3$modelStruct$corStruct
coef(mod3$modelStruct$corStruct, unconstrained=F)
as.numeric(exp(-1/coef(mod3$modelStruct$corStruct, unconstrained=F)))
mod3$modelStruct$corStruct
coef(mod3$modelStruct$corStruct, unconstrained=F)
mod3$modelStruct
mod3$modelStruct$corStruct
mod3$modelStruct$corStruct
mod3$sigma
mod3$modelStruct$corStruct
mod3$sigma^2
tibble(grp = "iid") %>%
mutate(sigma    = mod.iid.nlme$sigma) %>%
mutate(Variance = sigma^2,
Corr     = 0)
mod.ar1.nlme <- nlme::gls(model = y ~ factweek * (variety + block),
correlation = corAR1(form = ~ varweek | plot), # AR(1)
data = dat)
tibble(varstruct = "ar(1)") %>%
mutate(sigma         = mod.ar1.nlme$sigma,
rho           = mod.ar1.nlme$modelStruct$corStruct)
mod.ar1.nlme$modelStruct$corStruct
coef(mod.ar1.nlme$modelStruct$corStruct, unconstrained = TRUE)
coef(mod.ar1.nlme$modelStruct$corStruct, unconstrained = FALSE)
mod.ar1.nlme.VC <- tibble(varstruct = "ar(1)") %>%
mutate(sigma         = mod.ar1.nlme$sigma,
rho           = coef(mod.ar1.nlme$modelStruct$corStruct, unconstrained = FALSE))
mod.ar1.nlme.VC
tibble(varstruct = "ar(1)") %>%
mutate(sigma    = mod.ar1.nlme$sigma,
rho      = coef(mod.ar1.nlme$modelStruct$corStruct, unconstrained = FALSE)) %>%
mutate(Variance = sigma^2,
Corr1wk  = rho,
Corr2wk  = rho^2,
Corr3wk  = rho^3,
Corr4wk  = rho^4)
mod.ar1.glmm <- glmmTMB(formula = y ~ factweek * (variety + block)
+ ar1(varweek | plot),      # add random unit term to mimic error variance
dispformula = ~ 0, # fix original error variance to 0
REML = TRUE,       # needs to be stated since default = ML
data = dat)
glmmTMB(formula = y ~ factweek * (variety + block)
+ ar1(varweek + 0 | plot),      # add random unit term to mimic error variance
dispformula = ~ 0, # fix original error variance to 0
REML = TRUE,       # needs to be stated since default = ML
data = dat)
mod.ar1.glmm <- glmmTMB(formula = y ~ factweek * (variety + block)
+ ar1(varweek + 0 | plot) + (1|unit),      # add random unit term to mimic error variance
dispformula = ~ 0, # fix original error variance to 0
REML = TRUE,       # needs to be stated since default = ML
data = dat)
mod.ar1.glmm <- glmmTMB(formula = y ~ factweek * (variety + block)
+ ar1(varweek + 0 | plot) ,      # add random unit term to mimic error variance
#dispformula = ~ 0, # fix original error variance to 0
REML = TRUE,       # needs to be stated since default = ML
data = dat)
dat
mod.ar1.glmm <- glmmTMB(formula = y ~ factweek * (variety + block)
+ ar1(factweek + 0 | plot) ,      # add random unit term to mimic error variance
#dispformula = ~ 0, # fix original error variance to 0
REML = TRUE,       # needs to be stated since default = ML
data = dat)
mod.ar1.glmm
mod.ar1.glmm %>%
tidy(effects = "ran_pars", scales = "vcov")
mod.ar1.glmm %>%
tidy(effects = "ran_pars"
)
mod.ar1.glmm <- glmmTMB(formula = y ~ factweek * (variety + block)
+ ar1(factweek + 0 | plot) ,      # add random unit term to mimic error variance
dispformula = ~ 0, # fix original error variance to 0
REML = TRUE,       # needs to be stated since default = ML
data = dat)
mod.ar1.glmm %>%
tidy(effects = "ran_pars", scales = "vcov")
mod.ar1.glmm %>%
tidy(effects = "ran_pars"
)
mod.ar1.glmm %>%
tidy(effects = "ran_pars", scales ="corr")
mod.ar1.glmm %>%
tidy(effects = "ran_pars", scales ="sd-corr")
mod.ar1.glmm %>%
tidy(effects = "ran_pars", scales ="sd-cor")
mod.ar1.glmm %>%
tidy(effects = "ran_pars", scales ="sdcor")
mod.ar1.glmm
knitr::purl("autoregressive_time_series.Rmd", documentation = 0)
params <-
list(hilang = "sas")
# packages
pacman::p_load(dplyr, purrr, tibble, tidyr, stringr, # data handling
ggplot2, viridis,            # plot
nlme, lme4, glmmTMB, sommer, # mixed modelling
AICcmodavg, broom.mixed)     # mixed model extractions
# data
dat <- agriTutorial::sorghum %>%
rename(block = Replicate, plot = factplot) %>%
dplyr::select(y, variety, block, plot, factweek, varweek) %>%
as_tibble()
dat.wk1 <- dat %>% filter(factweek == "1") # subset data from first week only
mod.wk1 <- lm(formula = y ~ variety + block,
data = dat.wk1)
mod.iid.nlme <- nlme::gls(model = y ~ factweek * (variety + block),
correlation = NULL, # default, i.e. homoscedastic, independent errors
data = dat)
# Extract variance component estimates
mod.iid.nlme.VC <- tibble(varstruct = "iid") %>%
mutate(sigma    = mod.iid.nlme$sigma) %>%
mutate(Variance = sigma^2)
dat <- dat %>%
mutate(unit = 1:n() %>% as.factor) # new column with running number
mod.iid.glmm <- glmmTMB(formula = y ~ factweek * (variety + block)
+ (1 | unit),      # add random unit term to mimic error variance
dispformula = ~ 0, # fix original error variance to 0
REML = TRUE,       # needs to be stated since default = ML
data = dat)
# Extract variance component estimates
mod.iid.glmm.VC <- mod.iid.glmm %>%
tidy(effects = "ran_pars", scales = "vcov") %>%
separate(term, sep = "__", into = c("term", "grp"))
mod.ar1.nlme <- nlme::gls(model = y ~ factweek * (variety + block),
correlation = corAR1(form = ~ varweek | plot),
data = dat)
# Extract variance component estimates
mod.ar1.nlme.VC <- tibble(varstruct = "ar(1)") %>%
mutate(sigma    = mod.ar1.nlme$sigma,
rho      = coef(mod.ar1.nlme$modelStruct$corStruct, unconstrained = FALSE)) %>%
mutate(Variance = sigma^2,
Corr1wk  = rho,
Corr2wks = rho^2,
Corr3wks = rho^3,
Corr4wks = rho^4)
mod.ar1.glmm <- glmmTMB(formula = y ~ factweek * (variety + block)
+ ar1(factweek + 0 | plot), # add ar1 structure as random term to mimic error variance
dispformula = ~ 0, # fix original error variance to 0
REML = TRUE,       # needs to be stated since default = ML
data = dat)
# Extract variance component estimates
mod.ar1.glmm %>%
tidy(effects = "ran_pars", scales ="sdcor") %>%
separate(term, sep = "__", into = c("term", "grp"))
mod.ar1.glmm$sdr$cov
mod.ar1.glmm$fit$par
mod.ar1.glmm$fitted
mod.ar1.glmm$obj$par
mod.ar1.glmm$sdr$value
mod.ar1.glmm$sdr$sd
mod.ar1.glmm$sdr$cov.fixed
mod.ar1.glmm$sdr$par.random
mod.ar1.glmm$sdr$diag.cov.random
mod.ar1.glmm$modelInfo$reStruc
summary(mod.ar1.glmm)
VarCorr(mod.ar1.glmm)
VarCorr(mod.ar1.glmm) %>% as_tibble
x <- VarCorr(mod.ar1.glmm)
x$cond
x %>% unlist
x %>% simplify
x %>% simplify %>% as_tibble()
x %>% simplify %>% data.table()
x %>% simplify %>% unlist
x %>% simplify
x %>% simplify %>% as.data.frame()
VarCorr(mod.ar1.glmm)[[c("cond","Subject")]]
VarCorr(mod.ar1.glmm)
VarCorr(mod.ar1.glmm)[[c("cond")]]
VarCorr(mod.ar1.glmm)[[c("cond")]]$plot
x <- VarCorr(mod.ar1.glmm)
x %>% simplify
x
formatVC(
x,
digits = max(3, getOption("digits") - 2),
comp = "Std.Dev.")
formatVC(x)
x %>% print
x %>% formatVC
mod.ar1.glmm %>%tidy(effects = "ran_pars", scales ="sdcor")
?extract_vc
??extract_vc
devtools::install_github('m-clark/mixedup')
devtools::install_github('m-clark/mixedup')
install.packages("brms")
devtools::install_github('m-clark/mixedup')
params <-
list(hilang = "sas")
# packages
pacman::p_load(dplyr, purrr, tibble, tidyr, stringr, # data handling
ggplot2, viridis,            # plot
nlme, lme4, glmmTMB, sommer, # mixed modelling
AICcmodavg, broom.mixed)     # mixed model extractions
# data
dat <- agriTutorial::sorghum %>%
rename(block = Replicate, plot = factplot) %>%
dplyr::select(y, variety, block, plot, factweek, varweek) %>%
as_tibble()
dat.wk1 <- dat %>% filter(factweek == "1") # subset data from first week only
mod.wk1 <- lm(formula = y ~ variety + block,
data = dat.wk1)
mod.iid.nlme <- nlme::gls(model = y ~ factweek * (variety + block),
correlation = NULL, # default, i.e. homoscedastic, independent errors
data = dat)
# Extract variance component estimates
mod.iid.nlme.VC <- tibble(varstruct = "iid") %>%
mutate(sigma    = mod.iid.nlme$sigma) %>%
mutate(Variance = sigma^2)
dat <- dat %>%
mutate(unit = 1:n() %>% as.factor) # new column with running number
mod.iid.glmm <- glmmTMB(formula = y ~ factweek * (variety + block)
+ (1 | unit),      # add random unit term to mimic error variance
dispformula = ~ 0, # fix original error variance to 0
REML = TRUE,       # needs to be stated since default = ML
data = dat)
# Extract variance component estimates
mod.iid.glmm.VC <- mod.iid.glmm %>%
tidy(effects = "ran_pars", scales = "vcov") %>%
separate(term, sep = "__", into = c("term", "grp"))
mod.ar1.nlme <- nlme::gls(model = y ~ factweek * (variety + block),
correlation = corAR1(form = ~ varweek | plot),
data = dat)
# Extract variance component estimates
mod.ar1.nlme.VC <- tibble(varstruct = "ar(1)") %>%
mutate(sigma    = mod.ar1.nlme$sigma,
rho      = coef(mod.ar1.nlme$modelStruct$corStruct, unconstrained = FALSE)) %>%
mutate(Variance = sigma^2,
Corr1wk  = rho,
Corr2wks = rho^2,
Corr3wks = rho^3,
Corr4wks = rho^4)
mod.ar1.glmm <- glmmTMB(formula = y ~ factweek * (variety + block)
+ ar1(factweek + 0 | plot), # add ar1 structure as random term to mimic error variance
dispformula = ~ 0, # fix original error variance to 0
REML = TRUE,       # needs to be stated since default = ML
data = dat)
# Extract variance component estimates
# mod.ar1.glmm %>%
#   tidy(effects = "ran_pars", scales ="sdcor") %>%
#   separate(term, sep = "__", into = c("term", "grp"))
x <- VarCorr(mod.ar1.glmm)
x %>% simplify %>% as.data.frame()
mod.ar1.glmm %>% tidy(effects = "ran_pars", scales ="sdcor")
purrr::map(x, diag)
VarCorr(mod.ar1.glmm)[[component]]
glmmTMB::VarCorr(mod.ar1.glmm)
x <- glmmTMB::VarCorr(mod.ar1.glmm)
x$cond
x$zi
x$cond$plot
VarCorr(mod.ar1.glmm)$cond
VarCorr(mod.ar1.glmm)$cond %>% purrr::map(., diag)
VarCorr(mod.ar1.glmm)$cond %>% purrr::map(., diag) %>% unlist
VarCorr(mod.ar1.glmm)$cond %>% purrr::map(attr, 'correlation')
VarCorr(mod.ar1.glmm)$cond %>% purrr::map(attr, 'correlation')%>% purrr::map(remove_parens)
